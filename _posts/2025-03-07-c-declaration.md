---
layout: post
title: C++ declaration
date: 2025-03-07 18:47 -0800
categories: [programming-language, cpp]
tags: [cpp]
---

## Structured Binding

Structured binding
[dcl.struct.bind](https://eel.is/c%2B%2Bdraft/dcl.struct.bind) is easy to use
but has many pitfalls if you zoom in on the details. The first question is what
types do the binding variables have. Let's take a look at the below example.

```cpp
#include <iostream>
#include <type_traits>
using namespace std;
int main() {
  int a[] = {2, 3};
  auto& [x1, x2] = a;
  cout << "Is it int&: " << is_same_v<decltype(x1), int&> << endl;
  cout << "Is it int: " << is_same_v<decltype(x1), int> << endl;
  x1 = 4;
  cout << x1 << endl;
  return 0;
}
```

The corresponding cppinsight version is

```cpp
#include <iostream>
#include <type_traits>
using namespace std;
int main()
{
  int a[2] = {2, 3};
  int (&__a9)[2] = a;
  int & x1 = __a9[0];
  int & x2 = __a9[1];
  std::operator<<(std::cout, "Is it int&: ").operator<<(std::is_same_v<int, int &>).operator<<(std::endl);
  std::operator<<(std::cout, "Is it int: ").operator<<(std::is_same_v<int, int>).operator<<(std::endl);
  x1 = 4;
  std::cout.operator<<(x1).operator<<(std::endl);
  return 0;
}
```

You can see that the `ref-qualifier`, i.e., `&` or `&&` in the definition of a
structured binding applies to the binding as whole. Namely, it applies to the
temporary variable generated by the compiler. It does apply to the individual
bindings declared. Therefore, using `auto& [...]` avoids a copy, and it is
always a good practice to use `const auto& [...]` if we do not need to mutate
the bindings.

cppinsight assigns type `int&` to `x1` and `x2` which is wrong. `decltype(x1)`
should be `int`. This is the most tricky part about structured binding. The
binding variables are aliases to the members of the right side. They are NOT
references. The compiler does not generate reference variables for these
bindings. The correct version for the above example is

```cpp
#define x1 __a9[0]
#define x2 __a9[1]
```

Also, see
[Domján Dániel's slides](https://llvm.org/devmtg/2023-05/slides/TechnicalTalks-May11/02-Domjan-StructuredBindingsCombined.pdf).

Clang's parser for structured binding is
[here](https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/clang/lib/Parse/ParseDecl.cpp#L7306),
and the definition for binding variable is
[here](https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/clang/include/clang/AST/DeclCXX.h#L4161).
Function `void setBinding(QualType DeclaredType, Expr *Binding)` sets the type
of this binding and the expression it binds to. This function is mainly used in
[this function](https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/clang/lib/Sema/SemaDeclCXX.cpp#L1567),
which sets the binding based on the type of the right side of the declaration:
`ArrayType`, `VectorType`, `ComplexType`, `TupleLike` and
`MemberDecomposition`. It covers all cases mentioned in the
[standard](https://eel.is/c%2B%2Bdraft/dcl.struct.bind). Also, for each case,
it assigns the exact type of the right side component to the corresponding
binding. It is not a reference!

If you think this is the end of the story, then you underestimate the
complexity of C++. For the above example, let's add cv-qualifier `const`,
namely,

```cpp
int a[] = {2, 3};
const auto& [x1, x2] = a;
```

Then what is the type of `x1`? Th answer is `const int`. In this case, the
temporary variable `__a9` is of type `const int(& __a9)[2]`, so its element
type is `const int`. That is why `x1` has type `const int`. Note, in this case,
`a[0]` has type `const int&`. Also, the new code is equivalent to

```cpp
const int a[] = {2, 3};
auto& [x1, x2] = a;
```

This is the same with the tuple decomposition and member decomposition. See
below code.

```cpp
const tuple<int, int> a {2, 3};
auto& [x1, x2] = a;
static_assert( is_same_v<decltype(x1), const int> );
static_assert( is_same_v<tuple_element_t<0, decltype(a)>, const int> );
```

Note that this does not conflict with what we said before.

> it assigns the exact type of the right side component to the corresponding
> binding.

### Member Decomposition

[dcl.struct.bind]p8 says

> Otherwise, all of E's non-static data members shall be direct members of E or
> of the same base class of E

It talks about two cases.

1. If `E` has non-static data member, then `E`'s direct members are used for
   decomposition. Also, all its base classes should not have non-static data
   member. See
   [code](https://github.com/llvm/llvm-project/blob/f5f5286da3a64608b5874d70b32f955267039e1c/clang/lib/Sema/SemaDeclCXX.cpp#L1463).
2. If `E` does not have non-static data member, then its base class is used for
   decomposition, and rule #1 applies to this base class as well.

```cpp
struct A { int a; int b; };
struct B: public A { int c; };

int main() {
  B b;
  const auto& [x1] = b;
  return 0;
}
```

Above code failed to compile with an error message
`cannot decompose class type 'B': both it and its base class 'A' have non-static data members`.

```cpp
struct A { int a; int b; };
struct B: public A { };

int main() {
  B b;
  const auto& [x1] = b;
  return 0;
}
```

Above code fails to compile with error message
`type 'const B' decomposes into 2 elements, but only 1 name was provided`.
